from Crypto.PublicKey import RSA
from Crypto.Util.number import long_to_bytes, bytes_to_long
from time import sleep
import requests
import json

# n = 'be83760b75c7382d205ce14cc9470be4ae6158fabdd8157eeb04d269b4921899f4676e4a61ca34fed12a04a59638daa4069212c3c30b44d50f0557b9d14372174fe6cb5844be6eb2ab39fa7d688002675e486ca763b836be4e515fa43714b3e72edf1093e6826f6550f95300800a4879a698b4cf3f0d549a011d0302fd70858f'
# n = int(n, 16)
# e = 65537

cipher_hex = 'bac936c23a9aeb60b0c1891f3d37511c3fbe9a047a3625fe08c041418f441b59b70d8e91f1c55ce5365ebf4ff5d732f8d4bd06dd4843e1ed27d29d9a9b1df263549cf74528a908452ab1e9f1cc75dcc24755d11f654714a9e0a89c2f2fc20cc7e6494474fdbe0f07b0f2ca90e44fa415d4eb7ed0c842c0a45205051fd3a892a0'
cipher_int = int(cipher_hex, 16)

pub_key_file = '../pub.key'
public_key_data = open(pub_key_file, 'r').read()
public_key = RSA.importKey(public_key_data)
n = public_key.n
e = public_key.e
k = len(bin(n))//8 + 1

url = 'http://209.97.138.240:32704'
headers = {
    'Content-Type' : 'application/json'
}

proxies = {
    'http' : 'http://localhost:8080',
    'https' : 'https://localhost:8080'
}

def padding_oracle(c):

    # print(c)
    
    data = {
        'message' : str(hex(c))[2:]
    }
    # result = json.loads(requests.post(url, headers=headers, data=json.dumps(data), proxies=proxies).text)
    result = json.loads(requests.post(url, headers=headers, data=json.dumps(data)).text)

    if result['status'] == 'success':
        return True
    else:
        return False


def padding_oracle_attack(cipher):

    B = 2 ** (8 * (k-2))
    Mi = set([(2 * B, 3 * B - 1)])
    s_i = 1	
    count = 1
    working = True

    while working:
        siPrev = s_i	 			#step 2
        miPrev = Mi
        if count == 1:  			#2a
            
            s_i = n//(3*B)	#set s_1 as the first number above n/3B that has correct padding with C*(si)**e mod n
            # print(s_i)

            c = cipher * pow(s_i, e, n)
            # print(c)
            while not padding_oracle(c):

                s_i+=1
                c = cipher * pow(s_i, e, n)
        
        elif len(miPrev)>1: 		#2b
            
            s_i =  siPrev + 1		
            c = cipher * pow(s_i, e, n)

            while not padding_oracle(c):
                s_i+=1			#set s_1 as the first number above previous si that has correct padding with C*(si)**e mod n
                c = cipher * pow(s_i, e, n)
        
        else: 						#2c 
            
            a = list(miPrev)[0][0]
            b = list(miPrev)[0][1]

            ri = 2 * ((b * siPrev - 2 * B) / n)
            
            searching = True

            while searching:
                
                s_i = (2 * B + ri * n) / b
                maxSi = (3 * B + ri * n) / a

                while s_i <= maxSi:
                    
                    c = cipher * pow(s_i, e, n)
                    if padding_oracle(c):
                        searching = False		#if fits padding stop looking
                        break				#leave the while loop for iterating si
                    s_i += 1		#iterate through all si in the range
                
                ri+=1 #iterate through each ri

        
        Mi = set()					#begin step 3

        for a,b in miPrev:
            r, mod1 = divmod((a * s_i - 3 * B + 1), n)
            if mod1 != 0:
                r+=1
            maxR = (b * s_i - 2 * B) / n 
            
            while r <= maxR:
                bottom,mod1 = divmod(((2*B)+(r*n)),s_i)
                if mod1 != 0:
                    bottom +=1
                bottom = max(a,bottom)
                upper = divmod((((3*B)-1)+(r*n)),s_i)[0]
                upper = min(b,upper)
                Mi.add((bottom,upper))
                r+=1

        if len(Mi)==1: #begin step 4
            a = list(Mi)[0][0]
            b = list(Mi)[0][1]

            if a == b:
                message = long_to_bytes(a)

                m = '\x00'*(k-len(message)) + message
                print(m)
        count += 1



padding_oracle_attack(cipher_int)